function demoWindow() {
    let window = initWindow(0, 0, 700, 700, "RainbowUI Demo Window", "./System/window/testlogo.svg");
    window.DOMobj_container.style["overflow-y"] = "auto";
    html = `
        <div>
            <h1>RainbowUI Demo Window</h1>
            <p>这是一个RainbowUI的演示窗口。</p>
            <br></br>
            <h2>历史：</h2>
            <p>这个项目来源于1年前的一段幻想，当时重拾自己的GLSL着色器时，恰逢Vulkan新版本发布，就萌生了制作游戏引擎的想法。那时想要自己的游戏引擎能有一个好看的UI，正好在做静态网页，就开始了这个项目。</p>
            <p>此前的我对性能有极度的偏执，认为“除了ASM，C系，Pascal外，其它语言都非常慢，不值得用”，其中便包括了JS。但是我对造轮子一直有狂热的追求，于是就决定借这个项目来学习JS。</p>
            <p>开始总是困难的，尤其是一开始就要做一个大型项目，架构的设计比较顺利，但编码的时候就遇到了问题。在没有网，没有文档的情况下，我对着浏览器的F12控制台开始了盲人摸象般的摸索。这个项目逐渐成型的过程，也就是我逐渐学习JS的过程。很难想象，当时的我只能自己摸索，自己写代码，自己测试。通过控制台的Tab补全来尝试内置函数，摸索变量类型和运算符，现在想想，真是一段艰辛的旅程！</p>
            <p>进入大学后，我终于有了时间对这个项目开始重构和调整，发现自己当时幼稚的的“C味代码”居然把以前期待的性能给实现了，自那时起，我的偏见就慢慢地散去了。现在，我逐渐完善，健全它的架构。虽然游戏引擎的白日梦已经过去，但是我仍然对这个项目保持着浓厚的兴趣。现在的它，转向了一个纯粹的高性能窗口式UI。在我正在开发的MC结构-模型编辑器中，就使用了这个框架。以后的许多小工具，或许也能找到它的影子。</p>
            <p>再过一段时间，它就要被整合打包成一个真正的库了。</p>
            <p>回望前路，或许能说：这个项目，是我开发历程上一个重要的转折点。谢谢你，RainbowUI。</p>
            <br></br>
            <h2>特性：</h2>
            <p>按住窗口标题栏即可拖动窗口</p>
            <p>窗口可以被最大化，还原，有精心设计的非线性动画</p>
            <p>窗口右下角可以拖动，以更改窗口的大小</p>
            <p>窗口可以非常舒服地关闭</p>
            <p>窗口可以相互遮挡，正在操作的窗口总会在最上方，位于下面的窗口将会被模糊以表示其被遮挡，但是交互不受模糊层影响，可以无视模糊直接进行交互</p>
            <p>正在被拖动的窗口也会参与遮盖计算，意味着你在拖动时可以动态地看见下面的窗口被盖住和打开</p>
            <p>桌面可以被拖动，并且是（在IEEE754双精度浮点表示范围内）无限拖动</p>
            <p>桌面&窗口被拖动时有精心设计的运动模糊，极大补偿了拖动事件触发间隔导致的观感下降问题</p>
            <p>极高的可扩展性和开放性</p>
            <p>运用了近乎极限的性能优化，几乎所有的逻辑都是异步运行，极大提高了鲁棒性和稳定性，实测在极低配置（核显）下，10000窗口的极限测试中也可以半流畅运行</p>
            <br></br>
            <h2>调试功能（仅限此DEMO）：</h2>
            <p>单击左上角的调试按钮可以创建一个随机窗口，它将生成在屏幕中央</p>
            <p>在控制台中更改变量 _B 的值（true或false）以禁用和启用运动模糊（你会观察到非常明显的观感差异，即使是在165Hz的屏幕下）</p>
            <p>其它用于调试的快速接口调用，可以用来在控制台里面玩：</p>
            <p>_i()：创建窗口，参数为（X轴偏移，Y轴偏移，宽，高，窗口标题，窗口图标路径（暂不可用）），返回创建的窗口（偏移指窗口中心相对于视口中心的偏移量，水平向右为x正，水平向下为y正）</p>
            <p>_a()：根据给定的handle查找窗口，参数为：（Handle值）返回该窗口</p>
            <p>_m()：置顶指定的窗口，参数为：（窗口），无返回值</p>
            <p>_r()：简写，_r(x)等价于_m(_a(x))</p>
            <p>_M()：最大化指定的窗口，参数为：（窗口），无返回值</p>
            <p>_R()：还原指定的窗口，参数为：（窗口），无返回值</p>
            <p>_c()：关闭指定的窗口，参数为：（窗口），无返回值</p>
            <p>_A：存储所有窗口的数组</p>
            <p>_G：全局窗口遮挡表，存储了当前所有窗口的两两之间的"距离"（经过仔细考量与设计，定义为：窗口不重叠时，其边界上任意两点切比雪夫距离的最小值；窗口重叠时，任一窗口仅沿上下左右当中一轴移动，使得两窗口不重叠的单轴移动距离的最小值）</p>
            <br></br>
            <h2>by Purple Rain</h2>
            <h2>玩得开心>w<</h2>
        </div>
    `;
    window.DOMobj_container.innerHTML += html;
}
